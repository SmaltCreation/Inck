<?php

namespace Inck\ArticleBundle\Entity;

use Doctrine\ORM\EntityRepository;

/**
 * ArticleRepository
 *
 * This class was generated by the Doctrine ORM. Add your own custom
 * repository methods below.
 */
class ArticleRepository extends EntityRepository
{
    const ARTICLES_PER_PAGE = 10;

    /**
     * Récupère les articles en fonction des filtres
     *
     * Types disponibles :
     * Brouillons : as_draft
     * Publiés : published
     * En modération : in_moderation
     * En validation (modérés mais non publiés ou approuvés/désapprouvés) : in_validation
     * Désapprouvés : disapproved
     *
     * @param $filters
     * @param int $page
     * @throws \Exception
     * @return array
     */
    public function findByFilters($filters, $page = 1)
    {
        $this->checkFilters($filters);
        $this->convertFilters($filters);

        $qb = $this->createQueryBuilder('a');

        // Type d'article
        if(isset($filters['type']))
        {
            switch($filters['type'])
            {
                case 'as_draft':
                    $qb
                        ->where('a.asDraft = :asDraft')
                        ->setParameter('asDraft', true)
                        ->andWhere('a.postedAt IS NULL')
                        ->orderBy('a.createdAt', 'DESC');
                    break;

                case 'published':
                    $qb
                        ->where('a.published = :published')
                        ->setParameter('published', true)
                        ->orderBy('a.publishedAt', 'DESC');
                    break;

                case 'posted':
                    $qb
                        ->where(
                            $qb->expr()->isNotNull('a.postedAt')
                        )
                        ->orderBy('a.postedAt', 'DESC');
                    break;

                case 'in_moderation':
                    $qb
                        ->where('a.published = :published')
                        ->setParameter('published', false)
                        ->andWhere('a.asDraft = :asDraft')
                        ->setParameter('asDraft', false)
                        ->andWhere('a.postedAt >= DATE_SUB(CURRENT_TIMESTAMP(), 1, \'DAY\')')
                        ->orderBy('a.postedAt', 'DESC');
                    break;

                case 'in_validation':
                    $qb
                        ->where('a.approved IS :approved')
                        ->setParameter('approved', null)
                        ->andWhere('a.asDraft = :asDraft')
                        ->setParameter('asDraft', false)
                        ->andWhere('a.postedAt >= DATE_SUB(CURRENT_TIMESTAMP(), 2, \'DAY\')')
                        ->orderBy('a.postedAt', 'DESC');
                    break;

                case 'disapproved':
                    $qb
                        ->where('a.approved = :approved')
                        ->setParameter('approved', false)
                        ->orderBy('a.postedAt', 'DESC');
                    break;

                default:
                    throw new \Exception("Type d'article invalide.");
                    break;
            }
        }

        // Création des conditions pour les filtres
        $orx = $qb->expr()->orX();

        $conditions = array(
            'authors'       => 'author',
            'categories'    => 'categories',
            'tags'          => 'tags',
        );

        foreach($conditions as $filter => $field)
        {
            if(isset($filters[$filter]))
            {
                $qb->join("a.$field", $field);

                $orx->add(
                    $qb
                        ->expr()
                        ->in("$field.id", $filters[$filter])
                );
            }
        }

        $qb->andWhere($orx);

        // Offset et limit
//        $qb
//            ->setFirstResult(($page - 1) * self::ARTICLES_PER_PAGE)
//            ->setMaxResults(self::ARTICLES_PER_PAGE);

        $articles = $qb->getQuery()->getResult();
        $this->orderResults($filters, $articles);

        return $articles;
    }

    public function countByCategory($category, $published = false)
    {
        $query = $this->createQueryBuilder('a');

        $query->select('COUNT(a)')
            ->join('a.categories', 'c')
            ->where(
                $query->expr()->in('c.id', $category)
            )
            ->andWhere('a.published = :published')
            ->setParameter('published', $published)
        ;

        return (int) $query->getQuery()->getSingleScalarResult();
    }

    public function countByTag($tag, $published = false)
    {
        $query = $this->createQueryBuilder('a');

        $query->select('COUNT(a)')
            ->join('a.tags', 't')
            ->where(
                $query->expr()->in('t.id', $tag)
            )
            ->andWhere('a.published = :published')
            ->setParameter('published', $published)
        ;

        return (int) $query->getQuery()->getSingleScalarResult();
    }

    /**
     * Vérifie les filtres reçus
     * @param $filters mixed
     * @throws \Exception
     */
    private function checkFilters(&$filters)
    {
        if(!is_array($filters) || count($filters) === 0)
        {
            throw new \Exception("Filtres invalides");
        }

        $validFilters = array(
            'type',
            'authors',
            'author',
            'categories',
            'category',
            'tags',
            'tag',
        );

        $validTypes = array(
            'as_draft',
            'published',
            'posted',
            'in_moderation',
            'in_validation',
            'disapproved',
        );

        foreach($filters as $filter => $data)
        {
            if(!in_array($filter, $validFilters))
            {
                throw new \Exception("Filtre $filter non géré");
            }

            switch($filter)
            {
                case 'type':
                    if(!in_array($data, $validTypes))
                    {
                        throw new \Exception("Type $filter invalide");
                    }
                    break;

                case 'authors':
                case 'categories':
                case 'tags':
                    if(!is_array($data))
                    {
                        throw new \Exception("Filtre $filter invalide");
                    }
                    break;

                case 'author':
                case 'category':
                case 'tag':
                    if(!is_numeric($data))
                    {
                        throw new \Exception("Filtre $filter invalide");
                    }
                    break;

                default:
                    throw new \Exception("Filtre $filter invalide");
                    break;
            }
        }
    }

    /**
     * Converti les filtres reçus
     * @param $filters array
     */
    private function convertFilters(&$filters)
    {
        $conversion = array(
            'author'    => 'authors',
            'category'  => 'categories',
            'tag'       => 'tags',
        );

        foreach($conversion as $from => $to)
        {
            if(isset($filters[$from]))
            {
                if(isset($filters[$to]))
                {
                    $filters[$to][] = $filters[$from];
                }

                else
                {
                    $filters[$to] = array($filters[$from]);
                }

                unset($filters[$from]);
            }

            if(isset($filters[$to]) && !is_array($filters[$to]))
            {
                $filters[$to] = array($filters[$to]);
            }

            if(isset($filters[$to]) && count($filters[$to]) === 0)
            {
                unset($filters[$to]);
            }
        }
    }

    private function orderResults(&$filters, &$articles)
    {
        $configurations = array(
            'categories'    => array(
                'getCategories',
                2,
            ),
            'tags'    => array(
                'getTags',
                1,
            ),
        );

        /** @var $article Article */
        foreach($articles as $article)
        {
            $score = 0;

            foreach($configurations as $filter => $configuration)
            {
                list($method, $add) = $configuration;

                if(isset($filters[$filter]))
                {
                    foreach($article->$method() as $entity)
                    {
                        foreach($filters[$filter] as $id)
                        {
                            /** @var Category|Tag $entity */
                            if($entity->getId() === (int) $id)
                            {
                                $score += $add;
                                break;
                            }
                        }
                    }
                }
            }

            $article->setSearchScore($score);
        }

        usort($articles, function($a, $b){
            /**
             * @var Article $a
             * @var Article $b
             */
            return ($a->getSearchScore() < $b->getSearchScore()) ? 1 : -1;
        });
    }
}
