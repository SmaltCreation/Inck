<?php

namespace Inck\ArticleBundle\Entity;

use Doctrine\DBAL\Query\QueryBuilder;
use Doctrine\ORM\EntityRepository;

/**
 * ArticleRepository
 *
 * This class was generated by the Doctrine ORM. Add your own custom
 * repository methods below.
 */
class ArticleRepository extends EntityRepository
{
    const ARTICLES_PER_PAGE = 10;

    /**
     * Récupère les articles en fonction des filtres
     *
     * Types disponibles :
     * Brouillons : as_draft
     * Publiés : published
     * En modération : in_moderation
     * En validation (modérés mais non publiés ou approuvés/désapprouvés) : in_validation
     * Désapprouvés : disapproved
     *
     * @param $filters
     * @param int $page
     * @throws \Exception
     * @return array
     */
    public function findByFilters($filters, $page = 1)
    {
        $this->convertFilters($filters);
        $this->checkFilters($filters);

        $qb = $this->createQueryBuilder('a');

        // Type d'article
        if(isset($filters['type']))
        {
            switch($filters['type'])
            {
                case 'as_draft':
                    $qb
                        ->where('a.asDraft = :asDraft')
                        ->setParameter('asDraft', true)
                        ->andWhere('a.postedAt IS NULL')
                        ->orderBy('a.createdAt', 'DESC');
                    break;

                case 'published':
                    $qb
                        ->where('a.published = :published')
                        ->setParameter('published', true)
                        ->orderBy('a.publishedAt', 'DESC');
                    break;

                case 'posted':
                    $qb
                        ->where($qb
                            ->expr()
                            ->isNotNull('a.postedAt')
                        )
                        ->orderBy('a.postedAt', 'DESC');
                    break;

                case 'in_moderation':
                    $qb
                        ->where('a.published = :published')
                        ->setParameter('published', false)
                        ->andWhere('a.asDraft = :asDraft')
                        ->setParameter('asDraft', false)
                        ->andWhere('a.postedAt >= DATE_SUB(CURRENT_TIMESTAMP(), 1, \'DAY\')')
                        ->orderBy('a.postedAt', 'DESC');
                    break;

                case 'in_validation':
                    $qb
                        ->where('a.approved IS :approved')
                        ->setParameter('approved', null)
                        ->andWhere('a.asDraft = :asDraft')
                        ->setParameter('asDraft', false)
                        ->andWhere('a.postedAt >= DATE_SUB(CURRENT_TIMESTAMP(), 2, \'DAY\')')
                        ->orderBy('a.postedAt', 'DESC');
                    break;

                case 'disapproved':
                    $qb
                        ->where('a.approved = :approved')
                        ->setParameter('approved', false)
                        ->orderBy('a.postedAt', 'DESC');
                    break;

                default:
                    throw new \Exception("Type d'article invalide.");
                    break;
            }
        }

        // Création des conditions pour les filtres
        $orx = $qb->expr()->orX();

        $conditions = array(
            'authors'       => array(
                'field' => 'author',
                'alias' => 'u',
            ),
            'categories'    => array(
                'field' => 'categories',
                'alias' => 'c',
            ),
            'tags'          => array(
                'field' => 'tags',
                'alias' => 't',
            ),
        );

        $score = array();

        foreach($conditions as $filter => $parameters)
        {
            if(isset($filters[$filter]))
            {
                $qb->join('a.'.$parameters['field'], $parameters['field']);

                $orx->add($qb
                    ->expr()
                    ->in($parameters['field'].'.id', $filters[$filter])
                );

                $scoreAlias = $filter.'Score';
                $score[] = sprintf('SELECT(%s)', $scoreAlias);

                $qb
                    ->addSelect(sprintf(
                        '(SELECT COUNT(%s.id) FROM InckArticleBundle:Article a%s '
                        .'JOIN a%s.%s %s WHERE a%s.id = a.id AND %s.id IN (:%sParameter)) AS %sScore',
                        $parameters['alias'],
                        $parameters['alias'],
                        $parameters['alias'],
                        $parameters['field'],
                        $parameters['alias'],
                        $parameters['alias'],
                        $parameters['alias'],
                        $parameters['alias'],
                        $parameters['field']
                    ))
                    ->setParameter($parameters['alias'].'Parameter', $filters[$filter])
                    ->addOrderBy($parameters['field'].'Score', 'DESC');
            }
        }

        $qb->andWhere($orx);

        // Offset et limit
        $qb
            ->setFirstResult(($page - 1) * self::ARTICLES_PER_PAGE)
            ->setMaxResults(self::ARTICLES_PER_PAGE);

        $results = $qb->getQuery()->getResult();

        foreach($results as &$result)
        {
            if(is_array($result) && isset($result[0]))
            {
                $result = $result[0];
            }
        }

        return $results;
    }

    public function countByCategory($category, $published = false)
    {
        $qb = $this->createQueryBuilder('a');

        $qb->select('COUNT(a)')
            ->join('a.categories', 'c')
            ->where($qb
                ->expr()
                ->in('c.id', $category)
            )
            ->andWhere('a.published = :published')
            ->setParameter('published', $published)
        ;

        return (int) $qb->getQuery()->getSingleScalarResult();
    }

    public function countByTag($tag, $published = false)
    {
        $query = $this->createQueryBuilder('a');

        $query->select('COUNT(a)')
            ->join('a.tags', 't')
            ->where(
                $query->expr()->in('t.id', $tag)
            )
            ->andWhere('a.published = :published')
            ->setParameter('published', $published)
        ;

        return (int) $query->getQuery()->getSingleScalarResult();
    }

    /**
     * Vérifie les filtres reçus
     * @param $filters mixed
     * @throws \Exception
     */
    private function checkFilters(&$filters)
    {
        if(!is_array($filters) || count($filters) === 0)
        {
            throw new \Exception("Filtres invalides");
        }

        $validFilters = array(
            'type',
            'authors',
            'author',
            'categories',
            'category',
            'tags',
            'tag',
        );

        $validTypes = array(
            'as_draft',
            'published',
            'posted',
            'in_moderation',
            'in_validation',
            'disapproved',
        );

        foreach($filters as $filter => $data)
        {
            if(!in_array($filter, $validFilters))
            {
                throw new \Exception("Filtre $filter non géré");
            }

            switch($filter)
            {
                case 'type':
                    if(!in_array($data, $validTypes))
                    {
                        throw new \Exception("Type $filter invalide");
                    }
                    break;

                case 'authors':
                case 'categories':
                case 'tags':
                    if(!is_array($data))
                    {
                        throw new \Exception("Filtre $filter invalide");
                    }
                    break;

                case 'author':
                case 'category':
                case 'tag':
                    if(!is_numeric($data))
                    {
                        throw new \Exception("Filtre $filter invalide");
                    }
                    break;

                default:
                    throw new \Exception("Filtre $filter invalide");
                    break;
            }
        }
    }

    /**
     * Converti les filtres reçus
     * @param $filters array
     */
    private function convertFilters(&$filters)
    {
        $conversion = array(
            'author'    => 'authors',
            'category'  => 'categories',
            'tag'       => 'tags',
        );

        foreach($conversion as $from => $to)
        {
            if(isset($filters[$from]))
            {
                if(isset($filters[$to]))
                {
                    $filters[$to][] = $filters[$from];
                }

                else
                {
                    $filters[$to] = array($filters[$from]);
                }

                unset($filters[$from]);
            }

            if(isset($filters[$to]) && !is_array($filters[$to]))
            {
                $filters[$to] = array($filters[$to]);
            }

            if(isset($filters[$to]) && count($filters[$to]) === 0)
            {
                unset($filters[$to]);
            }
        }
    }
}
